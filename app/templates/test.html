{% load static %}
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WS Chat ‚Äî 3D Debug Console (RPM + Visemes)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="shortcut icon" type="image/x-icon" href="{% static 'favicon.ico' %}" />
  <style>
    html, body { height: 100%; }
    canvas { image-rendering: auto; }
    .json-pre { tab-size: 2; }
    label span.value { font-variant-numeric: tabular-nums; }
  </style>
</head>
<body class="bg-slate-50 min-h-screen">
  <div class="mx-auto max-w-7xl p-4 space-y-4">
    <!-- Header -->
    <header class="flex items-center justify-between">
      <div>
        <h1 class="text-2xl font-semibold text-slate-900">WS Chat ‚Äî 3D Viseme Debug</h1>
        <p class="text-slate-500 text-sm">
          Streams from <span class="font-mono">/ws/chat/</span> with Ready Player Me avatar mouth driven by visemes.
        </p>
      </div>
      <div class="flex items-center gap-3">
        <div id="emotionBadge" class="inline-flex items-center gap-2 rounded-full bg-slate-200 px-2 py-1 text-xs text-slate-700">
          <span class="h-2 w-2 rounded-full bg-slate-400 inline-block"></span> emotion: ‚Äî
        </div>
        <div id="audioBadge" class="inline-flex items-center gap-2 rounded-full bg-slate-200 px-2 py-1 text-xs text-slate-700">
          <span class="h-2 w-2 rounded-full bg-emerald-500 inline-block"></span> audio: unmuted
        </div>
        <div id="wsStatus" class="inline-flex items-center gap-2 rounded-full bg-slate-200 px-2 py-1 text-xs text-slate-700">
          <span class="h-2 w-2 rounded-full bg-slate-500 inline-block"></span> disconnected
        </div>
      </div>
    </header>

    <!-- Connect -->
    <section class="rounded-2xl bg-white ring-1 ring-black/5 p-4">
      <div class="grid gap-3 md:grid-cols-12">
        <div class="md:col-span-3">
          <label class="text-xs font-medium text-slate-600">Agent bot_id (UUID)</label>
          <input id="botId" class="w-full rounded border border-slate-300 p-2" placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx">
        </div>
        <div class="md:col-span-3">
          <label class="text-xs font-medium text-slate-600">Visitor thread_id</label>
          <input id="threadId" class="w-full rounded border border-slate-300 p-2" placeholder="user_0123456789abcdef">
        </div>
        <div class="md:col-span-2">
          <label class="text-xs font-medium text-slate-600">Website language</label>
          <select id="websiteLanguage" class="w-full rounded border border-slate-300 p-2">
            <option value="en" selected>en</option>
            <option value="es">es</option>
            <option value="fr">fr</option>
          </select>
        </div>
        <div class="md:col-span-2">
          <label class="text-xs font-medium text-slate-600">API Key</label>
          <input id="apiKey" class="w-full rounded border border-slate-300 p-2" placeholder="Api-Key value">
        </div>
        <div class="md:col-span-2 flex items-end">
          <button id="connectBtn" class="w-full rounded bg-blue-600 px-3 py-2 text-white hover:bg-blue-700">Connect</button>
        </div>
        <div class="md:col-span-12 flex flex-wrap items-end gap-2 pt-1">
          <button id="disconnectBtn" class="rounded bg-slate-200 px-3 py-2 text-slate-800 hover:bg-slate-300" disabled>Disconnect</button>
          <div class="ml-2 inline-flex gap-2">
            <button id="btnToggleMute" class="rounded bg-slate-800 px-3 py-2 text-white hover:bg-slate-900" disabled>Mute</button>
            <button id="btnStopAudio" class="rounded bg-rose-600 px-3 py-2 text-white hover:bg-rose-700" disabled>Stop Audio</button>
          </div>
          <button id="btnPing" class="ml-auto rounded bg-slate-800 px-3 py-2 text-white hover:bg-slate-900" disabled>Ping</button>
        </div>
      </div>
    </section>

    <!-- Avatar (Ready Player Me) -->
    <section class="rounded-2xl bg-white ring-1 ring-black/5 p-4 space-y-3">
      <div class="grid gap-3 md:grid-cols-12">
        <div class="md:col-span-7">
          <label class="text-xs font-medium text-slate-600">Ready Player Me GLB URL</label>
          <input id="glbUrl" class="w-full rounded border border-slate-300 p-2 font-mono text-xs" placeholder="https://models.readyplayer.me/.../model.glb">
        </div>
        <div class="md:col-span-2 flex items-end">
          <button id="loadAvatarBtn" class="w-full rounded bg-emerald-600 px-3 py-2 text-white hover:bg-emerald-700">Load Avatar</button>
        </div>
        <div class="md:col-span-3 grid grid-cols-3 gap-2 items-end">
          <div class="col-span-3">
            <label class="text-xs font-medium text-slate-600 flex items-center justify-between">
              <span>Viseme gain</span>
              <span class="value" id="visemeGainVal">1.20√ó</span>
            </label>
            <input id="visemeGain" type="range" min="50" max="250" step="5" value="120" class="w-full">
          </div>
          <div class="col-span-3">
            <label class="text-xs font-medium text-slate-600 flex items-center justify-between">
              <span>Smoothing (lerp)</span>
              <span class="value" id="visemeSmoothVal">0.20</span>
            </label>
            <input id="visemeSmooth" type="range" min="0" max="90" step="5" value="20" class="w-full">
          </div>
          <div class="col-span-3">
            <button id="btnVisemeTest" class="w-full rounded bg-slate-800 px-3 py-2 text-white hover:bg-slate-900">Test Mouth</button>
          </div>
        </div>
      </div>
      <div id="threeRoot" class="w-full h-[460px] rounded border border-slate-200 bg-slate-100 overflow-hidden"></div>
      <div class="text-xs text-slate-600">
        Detected morphs will be logged in <strong>Events</strong>. OVR =&nbsp;<code>viseme_*</code>. ARKit =&nbsp;<code>jawOpen/mouthFunnel/mouthPucker/mouthClose</code> (also accepts common RPM synonyms).
      </div>
    </section>

    <!-- Send -->
    <section class="rounded-2xl bg-white ring-1 ring-black/5 p-4">
      <div class="flex gap-2">
        <input id="chatInput" class="flex-1 rounded border border-slate-300 p-3 font-mono text-sm" placeholder='Type text and press Enter or click "Send"' />
        <button id="sendBtn" class="rounded bg-blue-600 px-4 py-2 text-white hover:bg-blue-700" disabled>Send</button>
      </div>

      <div class="mt-3 grid gap-3 md:grid-cols-12 items-center">
        <div class="md:col-span-8 flex items-center gap-3">
          <!-- Push-to-Talk -->
          <button id="pttButton"
                  class="rounded bg-emerald-600 px-4 py-2 text-white hover:bg-emerald-700 disabled:opacity-50 disabled:cursor-not-allowed"
                  title="Hold to record, release to send"
                  disabled>üé§ Hold to Talk</button>

          <!-- Permission helper (appears if mic denied) -->
          <button id="micPermBtn"
                  class="hidden rounded bg-amber-600 px-3 py-2 text-white hover:bg-amber-700"
                  title="Grant microphone permission">üîí Grant mic</button>

          <div id="micStatus" class="text-xs text-slate-600">mic: idle</div>
        </div>

        <div class="md:col-span-4 grid grid-cols-2 items-center gap-3">
          <label class="inline-flex items-center gap-2 text-xs text-slate-700 col-span-2 sm:col-span-1">
            <input id="muteOnSend" type="checkbox" class="rounded border-slate-300 text-blue-600">
            <span>Start this run muted</span>
          </label>
          <div class="flex items-center gap-2 justify-end col-span-2 sm:col-span-1">
            <label class="text-xs text-slate-600">Playback MIME</label>
            <select id="playbackMime" class="rounded border border-slate-300 p-1 text-sm">
              <option selected>audio/mpeg</option><option>audio/ogg</option><option>audio/webm</option>
              <option>audio/wav</option><option>audio/mp4</option>
            </select>
          </div>
        </div>
      </div>
    </section>

    <!-- Streams -->
    <section class="grid gap-4 lg:grid-cols-3">
      <div class="rounded-2xl bg-white ring-1 ring-black/5 p-4 flex flex-col">
        <div class="flex items-center justify-between mb-2">
          <h2 class="text-sm font-semibold text-slate-700">Text tokens (raw)</h2>
          <div class="flex gap-2">
            <button id="textCopy" class="rounded bg-slate-200 px-2 py-1 text-xs">Copy</button>
            <button id="textClear" class="rounded bg-slate-200 px-2 py-1 text-xs">Clear</button>
          </div>
        </div>
        <pre id="textTokens" class="h-48 overflow-y-auto bg-slate-50 border border-slate-200 rounded p-2 text-xs font-mono whitespace-pre-wrap"></pre>
      </div>

      <div class="rounded-2xl bg-white ring-1 ring-black/5 p-4 flex flex-col">
        <div class="flex items-center justify-between mb-2">
          <h2 class="text-sm font-semibold text-slate-700">Slides (pretty JSON)</h2>
          <div class="flex gap-2">
            <button id="slidesCopy" class="rounded bg-slate-200 px-2 py-1 text-xs">Copy</button>
            <button id="slidesClear" class="rounded bg-slate-200 px-2 py-1 text-xs">Clear</button>
          </div>
        </div>
        <pre id="slidesLog" class="json-pre h-80 overflow-y-auto bg-slate-50 border border-slate-200 rounded p-2 text-xs font-mono whitespace-pre"></pre>
      </div>

      <div class="rounded-2xl bg-white ring-1 ring-black/5 p-4 flex flex-col">
        <div class="flex items-center justify-between mb-2">
          <h2 class="text-sm font-semibold text-slate-700">Audio + visemes</h2>
          <div class="flex gap-2">
            <button id="audioCopy" class="rounded bg-slate-200 px-2 py-1 text-xs">Copy</button>
            <button id="audioClear" class="rounded bg-slate-200 px-2 py-1 text-xs">Clear</button>
          </div>
        </div>
        <pre id="audioLog" class="h-80 overflow-y-auto bg-slate-50 border border-slate-200 rounded p-2 text-xs font-mono whitespace-pre-wrap"></pre>
        <audio id="audioPlayer" class="mt-2 w-full" controls></audio>
      </div>
    </section>

    <section class="rounded-2xl bg-white ring-1 ring-black/5 p-4">
      <div class="flex items-center justify-between mb-2">
        <h2 class="text-sm font-semibold text-slate-700">Events</h2>
        <div class="flex gap-2">
          <button id="evtCopy" class="rounded bg-slate-200 px-2 py-1 text-xs">Copy</button>
          <button id="evtClear" class="rounded bg-slate-200 px-2 py-1 text-xs">Clear</button>
        </div>
      </div>
      <pre id="evtLog" class="h-60 overflow-y-auto bg-slate-50 border border-slate-200 rounded p-2 text-xs font-mono whitespace-pre-wrap"></pre>
    </section>
  </div>

  <!-- Import map for Three ESM -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
    }
  }
  </script>
<script type="module">
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  // ---------- config / helpers ----------
  const DEBUG = true;

  const $ = (s) => document.querySelector(s);
  const now = () => new Date().toLocaleTimeString();
  const logLine = (el, line) => { el.textContent += (el.textContent ? "\n" : "") + line; el.scrollTop = el.scrollHeight; };
  const copyText = (el) => navigator.clipboard.writeText(el.textContent || "");
  const clearEl = (el) => el.textContent = "";

  function normalizeThreadId(raw) {
    const x = (raw || '').trim();
    const m = x.match(/([0-9a-f]{16})$/i);
    if (x.startsWith('user_') && m) return `user_${m[1].toLowerCase()}`;
    if (m) return `user_${m[1].toLowerCase()}`;
    return x;
  }

  async function blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve((reader.result || '').toString());
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  function b64ToBlob(b64, mime) {
    let raw = b64, outMime = mime || $('#playbackMime').value || 'audio/mpeg';
    if (typeof b64 === 'string' && b64.startsWith('data:')) {
      outMime = b64.substring(5, b64.indexOf(';')) || outMime;
      raw = b64.split(',')[1] || '';
    }
    const bin = atob(raw);
    const buf = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) buf[i] = bin.charCodeAt(i);
    return new Blob([buf], { type: outMime });
  }
  const safeRevoke = (url) => { try { if (url) URL.revokeObjectURL(url); } catch {} };

  // Emotion badge
  function setEmotionBadge(name, intensity) {
    const el = $('#emotionBadge');
    const label = name ? `${name}` : '‚Äî';
    const dots = { joy:'bg-amber-400', anger:'bg-rose-500', sadness:'bg-blue-500', fear:'bg-purple-500', surprise:'bg-emerald-500' };
    const dot = dots[(name||'').toLowerCase()] || 'bg-slate-400';
    const strong = Math.max(1, Math.min(3, Number(intensity ?? 1)));
    el.innerHTML = `<span class="h-2 w-2 rounded-full ${dot} inline-block"></span> emotion: ${label} (${strong})`;
    el.classList.remove('bg-amber-100','bg-rose-100','bg-blue-100','bg-emerald-100');
    if ((name||'').toLowerCase()==='joy') el.classList.add('bg-amber-100');
    if ((name||'').toLowerCase()==='anger') el.classList.add('bg-rose-100');
    if ((name||'').toLowerCase()==='sadness') el.classList.add('bg-blue-100');
    if ((name||'').toLowerCase()==='surprise') el.classList.add('bg-emerald-100');
  }

  // ---------- WS ----------
  let ws = null;
  let audioMuted = false;

  // emotion-first gating (buffer tokens until we see emotion or timeout)
  let expectingEmotion = false;
  let tokenBuffer = '';
  let emotionFlushTimer = null;
  const EMOTION_GUARD_MS = 600; // small safety net in case of network reordering

  function beginEmotionGuard() {
    expectingEmotion = true;
    tokenBuffer = '';
    try { clearTimeout(emotionFlushTimer); } catch {}
    emotionFlushTimer = setTimeout(() => flushTokenBuffer(), EMOTION_GUARD_MS);
    // show ‚Äúwaiting‚Äù state
    setEmotionBadge('‚Ä¶', 1);
  }
  function onEmotionArrived() {
    expectingEmotion = false;
    try { clearTimeout(emotionFlushTimer); } catch {}
    emotionFlushTimer = null;
    flushTokenBuffer();
  }
  function flushTokenBuffer() {
    if (!tokenBuffer) return;
    $('#textTokens').textContent += tokenBuffer;
    $('#textTokens').scrollTop = $('#textTokens').scrollHeight;
    tokenBuffer = '';
  }

  function setBadge(connected){
    const el = $('#wsStatus');
    el.innerHTML = `<span class="h-2 w-2 rounded-full ${connected ? 'bg-emerald-500' : 'bg-slate-500'} inline-block"></span> ${connected ? 'connected' : 'disconnected'}`;
    el.classList.toggle('bg-emerald-100', connected);
    el.classList.toggle('bg-slate-200', !connected);
  }
  function setAudioBadge(muted){
    audioMuted = !!muted;
    const el = $('#audioBadge');
    const dot = audioMuted ? 'bg-rose-500' : 'bg-emerald-500';
    const txt = audioMuted ? 'audio: muted' : 'audio: unmuted';
    el.innerHTML = `<span class="h-2 w-2 rounded-full ${dot} inline-block"></span> ${txt}`;
    el.classList.toggle('bg-rose-100', audioMuted);
    el.classList.toggle('bg-emerald-100', !audioMuted);
    $('#btnToggleMute').textContent = audioMuted ? 'Unmute' : 'Mute';
  }
  function buildWsUrl() {
    const proto = location.protocol === 'https:' ? 'wss' : 'ws';
    const bot = encodeURIComponent($('#botId').value.trim());
    const thr = encodeURIComponent(normalizeThreadId($('#threadId').value.trim()));
    const lang = encodeURIComponent($('#websiteLanguage').value.trim() || 'en');
    const key = encodeURIComponent($('#apiKey').value.trim());
    return `${proto}://${location.host}/ws/chat/?bot_id=${bot}&thread_id=${thr}&website_language=${lang}&api_key=${key}`;
  }
  function setAuthCookie(){
    const key = $('#apiKey').value.trim();
    if (!key) return;
    const secure = location.protocol === 'https:' ? '; Secure' : '';
    document.cookie = `api_key=${encodeURIComponent(key)}; path=/; SameSite=Lax${secure}`;
  }

  // ---------- Three.js scene ----------
  let scene, camera, renderer, controls, avatarRoot = null;
  let visemeTargets = []; // { mesh, dict, dictLc, influences, ovr: map idx->morphIndex }
  let arkitTargets = [];  // { mesh, dict, dictLc, influences, a: {jawOpen,‚Ä¶} }
  const threeRoot = $('#threeRoot');

  function initThree() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8fafc);

    const w = threeRoot.clientWidth, h = threeRoot.clientHeight;
    camera = new THREE.PerspectiveCamera(35, w/h, 0.1, 100);
    camera.position.set(0, 1.55, 2.2);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(w, h);
    threeRoot.innerHTML = '';
    threeRoot.appendChild(renderer.domElement);

    // lights
    const key = new THREE.DirectionalLight(0xffffff, 1.0);
    key.position.set(1, 1.8, 2.5);
    scene.add(key);
    const fill = new THREE.DirectionalLight(0xffffff, 0.6);
    fill.position.set(-2, 1.2, 0.6);
    scene.add(fill);
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));

    controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.5, 0);
    controls.enableDamping = true;

    window.addEventListener('resize', onResize);
    tick();
  }
  function onResize() {
    if (!renderer || !camera) return;
    const w = threeRoot.clientWidth, h = threeRoot.clientHeight;
    camera.aspect = w/h; camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  }
  function tick(){
    requestAnimationFrame(tick);
    controls?.update();
    renderer?.render(scene, camera);
  }

  function clearAvatar() {
    if (avatarRoot) {
      scene.remove(avatarRoot);
      avatarRoot.traverse(n => {
        if (n.isMesh) {
          n.geometry?.dispose?.();
          if (Array.isArray(n.material)) n.material.forEach(m=>m.dispose?.());
          else n.material?.dispose?.();
        }
      });
      avatarRoot = null;
    }
    visemeTargets = [];
    arkitTargets = [];
  }

  function loadAvatar(glbUrl) {
    clearAvatar();
    const loader = new GLTFLoader().setCrossOrigin('anonymous');
    loader.load(glbUrl, (gltf) => {
      avatarRoot = gltf.scene || gltf.scenes?.[0];
      scene.add(avatarRoot);
      avatarRoot.scale.set(1,1,1);

      controls.target.set(0, 1.55, 0);
      camera.position.set(0, 1.55, 2.1);

      scanBlendshapes(avatarRoot);
      reportBlendshapes();

      if (!visemeTargets.length && !arkitTargets.length) {
        logLine($('#evtLog'), `[${now()}] ‚ö†Ô∏è No compatible morph targets were found on this model.`);
      } else {
        logLine($('#evtLog'), `[${now()}] avatar loaded; OVR=${visemeTargets.length>0} ARKit=${arkitTargets.length>0}`);
      }
    }, undefined, (err) => {
      logLine($('#evtLog'), `[${now()}] avatar load error: ${err?.message || err}`);
    });
  }

  // OVR names with common variants (we'll match case-insensitively)
  const OVR_SYNONYMS = {
    0:  ['viseme_sil'],
    1:  ['viseme_pp'],
    2:  ['viseme_ff'],
    3:  ['viseme_th'],
    4:  ['viseme_dd'],
    5:  ['viseme_kk'],
    6:  ['viseme_ch'],
    7:  ['viseme_ss'],
    8:  ['viseme_nn'],
    9:  ['viseme_rr'],
    10: ['viseme_aa'],
    11: ['viseme_e'],
    12: ['viseme_i'],
    13: ['viseme_o'],
    14: ['viseme_u'],
  };

  // ARKit primary + common RPM synonyms
  const ARKIT_CANON = [
    'jawOpen','mouthClose','mouthFunnel','mouthPucker',
    'mouthSmileLeft','mouthSmileRight','mouthFrownLeft','mouthFrownRight',
    'mouthDimpleLeft','mouthDimpleRight','mouthStretchLeft','mouthStretchRight',
    'tongueOut'
  ];
  const ARKIT_SYNONYMS = {
    jawOpen:        ['jawOpen','mouthOpen'],
    mouthClose:     ['mouthClose'],
    mouthFunnel:    ['mouthFunnel','lipsFunnel'],
    mouthPucker:    ['mouthPucker','lipsPucker'],
    mouthSmileLeft: ['mouthSmileLeft','mouthSmile'],
    mouthSmileRight:['mouthSmileRight'],
    mouthFrownLeft: ['mouthFrownLeft'],
    mouthFrownRight:['mouthFrownRight'],
    mouthDimpleLeft:['mouthDimpleLeft'],
    mouthDimpleRight:['mouthDimpleRight'],
    mouthStretchLeft:['mouthStretchLeft'],
    mouthStretchRight:['mouthStretchRight'],
    tongueOut:      ['tongueOut']
  };

  function scanBlendshapes(root) {
    visemeTargets = [];
    arkitTargets = [];
    root.traverse(obj => {
      if (!obj.isMesh || !obj.morphTargetDictionary || !obj.morphTargetInfluences) return;

      const dict = obj.morphTargetDictionary;
      const dictLc = {};
      for (const [k,v] of Object.entries(dict)) dictLc[String(k).toLowerCase()] = v;

      // OVR visemes (case-insensitive)
      const ovr = {};
      let hasOVR = false;
      for (let i=0;i<15;i++){
        const names = (OVR_SYNONYMS[i] || []).map(s=>s.toLowerCase());
        for (const n of names) {
          if (dictLc[n] != null) { ovr[i] = dictLc[n]; hasOVR = true; break; }
        }
      }
      if (hasOVR) {
        visemeTargets.push({ mesh: obj, dict, dictLc, influences: obj.morphTargetInfluences, ovr });
      }

      // ARKit (with synonyms, case-insensitive)
      const a = {};
      let hasARK = false;
      for (const key of ARKIT_CANON) {
        for (const name of ARKIT_SYNONYMS[key]) {
          const idx = dictLc[name.toLowerCase()];
          if (idx != null) { a[key] = idx; hasARK = true; break; }
        }
      }
      if (hasARK) {
        arkitTargets.push({ mesh: obj, dict, dictLc, influences: obj.morphTargetInfluences, a });
      }
    });
  }

  function reportBlendshapes() {
    const namesFound = new Set();
    for (const t of visemeTargets) {
      for (const [name] of Object.entries(t.dict)) if (String(name).toLowerCase().startsWith('viseme_')) namesFound.add(name);
    }
    const aFound = new Set();
    for (const t of arkitTargets) {
      for (const [k, arr] of Object.entries(ARKIT_SYNONYMS)) {
        for (const n of arr) if (t.dictLc[n.toLowerCase()] != null) aFound.add(n);
      }
    }
    logLine($('#evtLog'), `[${now()}] OVR morphs: ${namesFound.size ? Array.from(namesFound).sort().join(', ') : 'none'}`);
    logLine($('#evtLog'), `[${now()}] ARKit morphs: ${aFound.size ? Array.from(aFound).sort().join(', ') : 'none'}`);
  }

  // ----- ARKit<->OVR conversion helpers -----
  function arkitToOvr(out) {
    const ovr = new Array(15).fill(0);
    ovr[0]  = Math.max(0, 1 - out[0]);      // sil ~ inverse jaw
    ovr[1]  = out[2];                        // PP ~ mouthClose
    ovr[2]  = out[12];                       // FF ~ mouthStretch
    ovr[3]  = 0.5*(out[12]+out[13]);         // TH ~ stretch mix
    ovr[4]  = 0.4*out[2] + 0.6*out[8];       // DD ~ close+frown
    ovr[5]  = 0.4*out[0] + 0.2*out[1];       // kk ~ open+funnel
    ovr[6]  = 0.6*out[1] + 0.4*out[3];       // CH ~ funnel+pucker
    ovr[7]  = out[12];                       // SS ~ stretch
    ovr[8]  = 0.2*out[2];                    // nn ~ slight close
    ovr[9]  = 0.3*out[1];                    // RR ~ funnelish
    ovr[10] = out[0];                        // aa ~ jawOpen
    ovr[11] = 0.4*out[12] + 0.2*out[0];      // E
    ovr[12] = 0.6*out[12] + 0.2*out[0];      // I
    ovr[13] = 0.8*out[1] + 0.6*out[3];       // O ~ funnel+pucker
    ovr[14] = 0.9*out[3];                    // U ~ pucker
    return ovr.map(v => Math.max(0, Math.min(1, v)));
  }
  function ovrToArkit(vals) {
    const out = new Array(15).fill(0);
    out[0]  = vals[10];                      // jawOpen ~ aa
    out[1]  = Math.max(vals[13], vals[14]);  // mouthFunnel ~ O/U
    out[2]  = vals[1];                       // mouthClose ~ PP
    out[3]  = vals[14];                      // mouthPucker ~ U
    out[12] = Math.max(vals[2], vals[7]);    // stretch
    out[13] = vals[7];
    out[4]  = 0.5*vals[10];                  // smile L/R from vowels
    out[5]  = 0.5*vals[10];
    return out.map(v => Math.max(0, Math.min(1, v)));
  }

  // UI gain + smoothing
  const gainEl = $('#visemeGain');
  const gainVal = $('#visemeGainVal');
  const smoothEl = $('#visemeSmooth');
  const smoothVal = $('#visemeSmoothVal');

  function getGain() { return (Number(gainEl.value || 100) / 100); }
  function getSmooth() { return (Number(smoothEl.value || 0) / 100); }
  gainEl.oninput = () => gainVal.textContent = `${getGain().toFixed(2)}√ó`;
  smoothEl.oninput = () => smoothVal.textContent = `${getSmooth().toFixed(2)}`;

  function resetMorphs() {
    const zero = new Array(15).fill(0);
    prevFrame = zero.slice();
    // ARKit via synonym-resolved indices
    for (const t of arkitTargets) {
      const d = t.a, inf = t.influences;
      const fields = [
        'jawOpen','mouthFunnel','mouthClose','mouthPucker',
        'mouthSmileLeft','mouthSmileRight','mouthFrownLeft','mouthFrownRight',
        'mouthDimpleLeft','mouthDimpleRight','mouthStretchLeft','mouthStretchRight',
        'tongueOut'
      ];
      for (const key of fields) { const k = d[key]; if (k != null) inf[k] = 0; }
    }
    // OVR
    for (const t of visemeTargets) {
      const inf = t.influences;
      for (let i=0;i<15;i++) {
        const idx = t.ovr[i];
        if (idx != null) inf[idx] = 0;
      }
    }
  }

  let prevFrame = new Array(15).fill(0);
  function applyVisemeFrame(frame, fmt='arkit15') {
    const f = Array.isArray(frame) ? frame.slice(0,15) : [];
    // pre-scale + smooth
    const out = new Array(15).fill(0);
    const g = getGain();
    const s = getSmooth();
    for (let i=0;i<15;i++){
      const target = Math.max(0, Math.min(1, Number(f[i] ?? 0)));
      const sm = prevFrame[i] + (target - prevFrame[i]) * (1 - s); // low-pass
      out[i] = Math.max(0, Math.min(1, sm * g));
    }
    prevFrame = out;

    // If we have ARKit morphs and fmt is ARKit => drive directly
    if (fmt === 'arkit15' && arkitTargets.length) {
      for (const t of arkitTargets) {
        const d = t.a, inf = t.influences;
        if (d.jawOpen      != null) inf[d.jawOpen]      = out[0];
        if (d.mouthFunnel  != null) inf[d.mouthFunnel]  = out[1];
        if (d.mouthClose   != null) inf[d.mouthClose]   = out[2];
        if (d.mouthPucker  != null) inf[d.mouthPucker]  = out[3];
        const more = [
          ["mouthSmileLeft",4],["mouthSmileRight",5],["mouthFrownLeft",8],["mouthFrownRight",9],
          ["mouthDimpleLeft",10],["mouthDimpleRight",11],["mouthStretchLeft",12],["mouthStretchRight",13],
          ["tongueOut",14],
        ];
        for (const [canon, idx] of more) {
          const k = d[canon];
          if (k != null) inf[k] = out[idx];
        }
      }
      return;
    }

    // If fmt is ARKit but only OVR exists -> convert
    if (fmt === 'arkit15' && visemeTargets.length && !arkitTargets.length) {
      const vals = arkitToOvr(out);
      for (const t of visemeTargets) {
        const inf = t.influences;
        for (let i=0;i<15;i++) {
          const idx = t.ovr[i];
          if (idx != null) inf[idx] = vals[i];
        }
      }
      return;
    }

    // fmt is OVR and we have OVR -> drive directly
    if (fmt === 'ovr15' && visemeTargets.length) {
      for (const t of visemeTargets) {
        const inf = t.influences;
        for (let i=0;i<15;i++) {
          const idx = t.ovr[i];
          if (idx != null) inf[idx] = out[i];
        }
      }
      return;
    }

    // fmt is OVR but only ARKit exists -> convert
    if (fmt === 'ovr15' && arkitTargets.length && !visemeTargets.length) {
      const vals = ovrToArkit(out);
      for (const t of arkitTargets) {
        const d = t.a, inf = t.influences;
        if (d.jawOpen      != null) inf[d.jawOpen]      = vals[0];
        if (d.mouthFunnel  != null) inf[d.mouthFunnel]  = vals[1];
        if (d.mouthClose   != null) inf[d.mouthClose]   = vals[2];
        if (d.mouthPucker  != null) inf[d.mouthPucker]  = vals[3];
      }
    }
  }

  // ---------- audio queue + viseme sync ----------
  const audioEl = $('#audioPlayer');
  const audioQ = [];
  let playing = false;
  let activeFrames = [];  // [[15]]
  let activeTimes = null; // [seconds] or null
  let activeFmt = 'arkit15';
  let activeUrl = null;
  let visemeRAF = null;

  function lerpFrame(a, b, t) {
    const out = new Array(15).fill(0);
    const tt = Math.max(0, Math.min(1, t));
    for (let i=0;i<15;i++) {
      const av = Number(a?.[i] ?? 0);
      const bv = Number(b?.[i] ?? 0);
      out[i] = av + (bv - av) * tt;
    }
    return out;
  }

  function startVisemeLoop(){
    stopVisemeLoop();
    let lastIdx = 0;
    const step = () => {
      if (!activeFrames.length || !isFinite(audioEl.duration) || audioEl.duration <= 0) {
        visemeRAF = requestAnimationFrame(step);
        return;
      }
      const t = audioEl.currentTime;

      if (activeTimes && activeTimes.length === activeFrames.length) {
        const times = activeTimes;
        if (t <= times[0]) {
          applyVisemeFrame(activeFrames[0], activeFmt);
        } else if (t >= times[times.length - 1]) {
          applyVisemeFrame(activeFrames[activeFrames.length - 1], activeFmt);
        } else {
          while (lastIdx < times.length - 2 && t >= times[lastIdx + 1]) lastIdx++;
          const t0 = times[lastIdx];
          const t1 = times[lastIdx + 1];
          const f0 = activeFrames[lastIdx];
          const f1 = activeFrames[lastIdx + 1];
          const alpha = (t1 > t0) ? (t - t0) / (t1 - t0) : 0;
          applyVisemeFrame(lerpFrame(f0, f1, alpha), activeFmt);
        }
      } else {
        const frac = Math.min(0.9999, Math.max(0, t / audioEl.duration));
        const idx = Math.floor(frac * activeFrames.length);
        applyVisemeFrame(activeFrames[idx] || activeFrames[activeFrames.length-1], activeFmt);
      }

      visemeRAF = requestAnimationFrame(step);
    };
    visemeRAF = requestAnimationFrame(step);
  }
  function stopVisemeLoop(){
    if (visemeRAF) cancelAnimationFrame(visemeRAF);
    visemeRAF = null;
  }

  function clearAudioQueue() {
    try { audioEl.pause(); } catch {}
    if (activeUrl) safeRevoke(activeUrl);
    audioEl.removeAttribute('src');
    audioEl.load();
    while (audioQ.length) {
      const item = audioQ.shift();
      if (item?.url) safeRevoke(item.url);
    }
    playing = false;
    activeFrames = [];
    activeTimes = null;
    activeUrl = null;
    activeFmt = 'arkit15';
    stopVisemeLoop();
    resetMorphs();
  }

  function queueAudio(b64, framesSpec, fmt='arkit15', info='') {
    try {
      const mime = $('#playbackMime').value;
      const blob = b64ToBlob(b64, mime);
      const url = URL.createObjectURL(blob);

      // framesSpec can be array (frames) OR {frames, times?, fps?}
      let frames = [];
      let times = null;
      let fps = 0;
      if (Array.isArray(framesSpec)) {
        frames = framesSpec;
      } else if (framesSpec && typeof framesSpec === 'object') {
        frames = Array.isArray(framesSpec.frames) ? framesSpec.frames : [];
        if (Array.isArray(framesSpec.times)) times = framesSpec.times.map(Number);
        fps = Number(framesSpec.fps || framesSpec.viseme_fps || 0);
        if (!times && fps > 0 && frames.length) times = frames.map((_, i) => i / fps);
      }

      audioQ.push({ url, frames, times, fmt });
      logLine($('#audioLog'), `[${now()}] queued (${mime}) fmt=${fmt} frames=${frames.length} ${info}`);
      playNext();
    } catch (e) {
      logLine($('#audioLog'), `[${now()}] ! queue error: ${e}`);
    }
  }

  function playNext(){
    if (playing || !audioQ.length) return;
    playing = true;

    // free previous URL early (we also free on ended/error; this helps mid-queue)
    if (activeUrl) safeRevoke(activeUrl);

    const item = audioQ.shift();
    activeFrames = item.frames || [];
    activeTimes = Array.isArray(item.times) ? item.times : null;
    activeUrl = item.url;
    activeFmt = item.fmt || 'arkit15';

    // Ensure zero start/end padding if backend didn‚Äôt send it
    if (activeFrames.length) {
      const isZero = (f) => !f || f.every(v => Number(v||0) === 0);
      if (!isZero(activeFrames[0])) activeFrames = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], ...activeFrames];
      if (!isZero(activeFrames[activeFrames.length-1])) activeFrames = [...activeFrames, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]];
      if (activeTimes && activeTimes.length === (activeFrames.length - 2)) {
        const head = Math.max(0, activeTimes[0] - 0.02);
        const tail = activeTimes[activeTimes.length - 1] + 0.02;
        activeTimes = [head, ...activeTimes, tail];
      }
    }

    audioEl.src = item.url;
    audioEl.onloadedmetadata = () => {
      if (!activeTimes && activeFrames.length && isFinite(audioEl.duration) && audioEl.duration > 0) {
        const dur = audioEl.duration;
        activeTimes = activeFrames.map((_, i) => (i / Math.max(1, activeFrames.length - 1)) * dur);
      }
      const effFps = (activeTimes && activeTimes.length > 1)
        ? (activeTimes.length - 1) / (activeTimes[activeTimes.length - 1] - activeTimes[0])
        : (activeFrames.length / Math.max(0.001, audioEl.duration));
      logLine($('#audioLog'), `[${now()}] ‚ñ∂ playing dur=${audioEl.duration.toFixed(2)}s ~${effFps.toFixed(1)} fps fmt=${activeFmt}`);
    };
    const onFinish = () => {
      safeRevoke(activeUrl);
      playing = false;
      activeFrames = [];
      activeTimes = null;
      stopVisemeLoop();
      resetMorphs();
      playNext();
    };
    audioEl.onended = onFinish;
    audioEl.onerror = onFinish;
    audioEl.onplay = () => startVisemeLoop();
    audioEl.onpause = () => stopVisemeLoop();

    audioEl.play().catch(err => {
      logLine($('#audioLog'), `[${now()}] ! playback error: ${err}`);
      onFinish();
    });
  }

  // ---------- WS wiring ----------
  $('#loadAvatarBtn').onclick = (e) => {
    e.preventDefault();
    const url = $('#glbUrl').value.trim();
    if (!url) { alert('Provide a Ready Player Me GLB URL'); return; }
    loadAvatar(url);
  };

  // Test mouth button (ARKit: jawOpen = 1 for 600ms)
  $('#btnVisemeTest').onclick = (e) => {
    e.preventDefault();
    const f = new Array(15).fill(0); f[0] = 1; // jawOpen
    applyVisemeFrame(f, 'arkit15');
    setTimeout(() => applyVisemeFrame(new Array(15).fill(0), 'arkit15'), 600);
  };

  $('#connectBtn').onclick = (e) => {
    e.preventDefault();
    const bot=$('#botId').value.trim(), thr=$('#threadId').value.trim(), key=$('#apiKey').value.trim();
    if (!bot || !thr || !key) { alert('bot_id, thread_id, api key required'); return; }
    $('#threadId').value = normalizeThreadId(thr);
    setAuthCookie();
    const url = buildWsUrl();
    ws = new WebSocket(url);
    ws.onopen = () => {
      setBadge(true);
      $('#sendBtn').disabled = false;
      $('#disconnectBtn').disabled = false;
      $('#btnPing').disabled = false;
      $('#btnToggleMute').disabled = false;
      $('#btnStopAudio').disabled = false;
      $('#pttButton').disabled = false;
      updateMicPermBadge();
      logLine($('#evtLog'), `[${now()}] open ${url}`);
    };
    ws.onclose = (ev) => {
      setBadge(false);
      $('#sendBtn').disabled = true;
      $('#disconnectBtn').disabled = true;
      $('#btnPing').disabled = true;
      $('#btnToggleMute').disabled = true;
      $('#btnStopAudio').disabled = true;
      $('#pttButton').disabled = true;
      logLine($('#evtLog'), `[${now()}] close code=${ev.code}`);
      clearAudioQueue();
      // clear emotion guard
      expectingEmotion = false; tokenBuffer = ''; try { clearTimeout(emotionFlushTimer); } catch {}
    };
    ws.onerror = (ev) => logLine($('#evtLog'), `[${now()}] error ${ev?.message || ''}`);

    ws.onmessage = (evt) => {
      let msg = {};
      try { msg = JSON.parse(evt.data || '{}'); } catch { msg = {}; }
      const t = msg.type || '';
      switch (t) {
        case 'connected':
          logLine($('#evtLog'), `[${now()}] connected bot=${msg.bot_id} thread=${msg.thread_id}`);
          break;

        case 'response_start':
          logLine($('#evtLog'), `[${now()}] response_start`);
          beginEmotionGuard(); // wait for emotion before rendering text
          break;

        case 'audio_muted':
          setAudioBadge(!!msg.muted);
          audioEl.muted = !!msg.muted;         // keep local player in sync
          logLine($('#evtLog'), `[${now()}] audio_muted=${!!msg.muted}`);
          break;

        case 'stop_audio':
          clearAudioQueue();
          logLine($('#evtLog'), `[${now()}] stop_audio`);
          break;

        case 'text_token': {
          const tok = (msg.token || '').toString();
          if (expectingEmotion) {
            tokenBuffer += tok;
          } else {
            $('#textTokens').textContent += tok;
            $('#textTokens').scrollTop = $('#textTokens').scrollHeight;
          }
          break;
        }

        case 'emotion': {
          const e = msg.emotion || {};
          setEmotionBadge(e.name, e.intensity);
          onEmotionArrived(); // flush buffered tokens
          logLine($('#evtLog'), `[${now()}] emotion ${JSON.stringify(e)}`);
          if (DEBUG) { console.log('[emotion/raw]', msg); }
          window.__lastEmotion = msg;
          break;
        }

        case 'slides_response': {
          const payload = ('slides' in msg) ? {slides: msg.slides}
                        : ('slides_raw' in msg) ? {slides_raw: msg.slides_raw} : msg;
          const pretty = JSON.stringify(payload, null, 2);
          logLine($('#slidesLog'), pretty + "\n");
          break;
        }

        case 'slides_done':
          logLine($('#slidesLog'), `-- slides_done --`);
          break;

        case 'audio_response': {
          const b64 = msg.audio || '';
          const frames = Array.isArray(msg.viseme) ? msg.viseme : [];
          const fmt = (msg.viseme_format || 'arkit15').toLowerCase();

          // Prefer explicit timing (seconds). Else synthesize from fps or frame_ms.
          let times = Array.isArray(msg.viseme_times) ? msg.viseme_times.map(Number) : null;
          const fps = Number(msg.viseme_fps || 0);
          const frameMs = Number(msg.viseme_frame_ms || msg.frame_ms || 0);
          if (!times && !fps && frameMs > 0 && frames.length) {
            const step = frameMs / 1000;
            times = Array.from({length: frames.length}, (_, i) => i * step);
          }

          let framesSpec = times ? { frames, times }
                                : (fps > 0 ? { frames, fps } : frames);

          const preview = typeof b64 === 'string'
            ? (b64.startsWith('data:') ? b64.split(',')[1] || '' : b64)
            : '';
          const head = preview.slice(0, 96);

          if (DEBUG) {
            console.groupCollapsed('[audio_response/raw]');
            console.log('format:', fmt);
            if (times) console.log('times[0..3]:', times.slice(0,4));
            if (fps) console.log('fps:', fps);
            console.log('audio head:', head);
            console.groupEnd();
          }
          window.__lastViseme = { fmt, framesLen: frames.length, times, fps, head };

          queueAudio(b64, framesSpec, fmt, `head=${head}‚Ä¶`);
          break;
        }

        case 'response_done':
          flushTokenBuffer(); // in case we timed out on emotion
          logLine($('#evtLog'), `[${now()}] response_done timings=${JSON.stringify(msg.timings || {})}`);
          break;

        case 'response_ended':
          flushTokenBuffer();
          logLine($('#evtLog'), `[${now()}] response_ended`);
          break;

        case 'text_query':
          logLine($('#evtLog'), `[${now()}] echo text_query "${(msg.text||'').slice(0,200)}"`);
          break;

        case 'pong':
          logLine($('#evtLog'), `[${now()}] pong`);
          break;

        case 'error':
          logLine($('#evtLog'), `[${now()}] ERROR ${msg.message || 'unknown'}`);
          break;

        default:
          logLine($('#evtLog'), `[${now()}] ${t || 'unknown'} ${JSON.stringify(msg)}`);
      }
    };
  };

  $('#disconnectBtn').onclick = (e) => { e.preventDefault(); if (ws) { ws.close(); ws = null; } };
  $('#btnPing').onclick = (e) => { e.preventDefault(); if (ws && ws.readyState === 1) ws.send(JSON.stringify({type:'ping'})); };
  $('#btnToggleMute').onclick = (e) => {
    e.preventDefault();
    if (!ws || ws.readyState !== 1) return;
    const nextMuted = !audioMuted;
    audioEl.muted = nextMuted;          // local immediate effect
    setAudioBadge(nextMuted);           // reflect instantly
    ws.send(JSON.stringify({ type: nextMuted ? 'mute_audio' : 'unmute_audio' }));
  };
  $('#btnStopAudio').onclick = (e) => {
    e.preventDefault();
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify({ type: 'stop_audio' }));
    clearAudioQueue();
  };

  $('#sendBtn').onclick = sendText;
  $('#chatInput').addEventListener('keydown', (e)=>{ if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendText(); }});
  function sendText(){
    if (!ws || ws.readyState !== 1) return;
    const text = $('#chatInput').value.trim();
    if (!text) return;
    const muted = $('#muteOnSend').checked;
    ws.send(JSON.stringify({
      type: 'text_query',
      text,
      local_time: new Date().toLocaleString(),
      muteAudio: muted
    }));
    $('#chatInput').value = '';
  }

  // ---------- Push-to-Talk (hold/release) ----------
  let mediaStream = null, recorder = null, chunks = [];
  let recMime = 'audio/webm';

  function pickRecorderMime() {
    const candidates = [
      'audio/webm;codecs=opus',
      'audio/webm',
      'audio/mp4;codecs=mp4a.40.2',
      'audio/mp4',
      'audio/ogg;codecs=opus',
      'audio/ogg'
    ];
    for (const m of candidates) {
      if (typeof MediaRecorder !== 'undefined' && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m)) {
        return m;
      }
    }
    return 'audio/webm'; // fallback
  }

  async function ensureMic() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      return stream;
    } catch {
      return null;
    }
  }

  function updateMicPermBadge() {
    const btn = $('#micPermBtn');
    if (navigator.permissions && navigator.permissions.query) {
      navigator.permissions.query({ name: 'microphone' }).then(st => {
        const denied = st.state === 'denied';
        btn.classList.toggle('hidden', !denied);
        $('#micStatus').textContent = `mic: ${st.state}`;
      }).catch(() => {});
    }
  }

  async function startPTT() {
    if (!ws || ws.readyState !== 1) return;
    $('#pttButton').classList.add('ring-4','ring-emerald-300');
    $('#micStatus').textContent = 'recording‚Ä¶';
    try {
      mediaStream = await ensureMic();
      if (!mediaStream) {
        $('#micStatus').textContent = 'mic blocked/denied';
        $('#micPermBtn').classList.remove('hidden');
        $('#pttButton').classList.remove('ring-4','ring-emerald-300');
        return;
      }
      recMime = pickRecorderMime();
      recorder = new MediaRecorder(mediaStream, { mimeType: recMime, audioBitsPerSecond: 64000 });
      chunks = [];
      recorder.ondataavailable = (ev) => { if (ev.data && ev.data.size) chunks.push(ev.data); };
      recorder.start();
    } catch (e) {
      $('#micStatus').textContent = `! mic error: ${e}`;
      $('#micPermBtn').classList.remove('hidden');
      $('#pttButton').classList.remove('ring-4','ring-emerald-300');
    }
  }

  async function stopPTT(send=true) {
    $('#pttButton').classList.remove('ring-4','ring-emerald-300');
    try {
      if (!recorder) { $('#micStatus').textContent = 'mic: idle'; return; }
      await new Promise(res => { recorder.onstop = res; recorder.stop(); });
      const blob = new Blob(chunks, { type: recMime });
      if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
      recorder = null; mediaStream = null;
      const dataUrl = await blobToBase64(blob);
      const b64 = (dataUrl.split(',')[1] || '');
      if (send && ws && ws.readyState === 1) {
        ws.send(JSON.stringify({
          type: 'audio_query',
          audio: dataUrl,
          format: (recMime.includes('mp4') ? 'm4a' : recMime.includes('ogg') ? 'ogg' : 'webm'),
          muteAudio: $('#muteOnSend').checked
        }));
        logLine($('#evtLog'), `[${now()}] sent audio_query size=${b64.length} fmt=${recMime}`);
        $('#micStatus').textContent = `sent (${(blob.size/1024).toFixed(1)} KB)`;
      } else {
        $('#micStatus').textContent = 'not connected';
      }
    } catch (e3) {
      $('#micStatus').textContent = `! send error: ${e3}`;
    } finally {
      chunks = [];
      setTimeout(()=>$('#micStatus').textContent='mic: idle', 800);
    }
  }

  // PTT bindings (mouse + touch)
  const ptt = $('#pttButton');
  ptt.addEventListener('mousedown', (e)=>{ e.preventDefault(); startPTT(); });
  ptt.addEventListener('touchstart', (e)=>{ e.preventDefault(); startPTT(); }, {passive:false});
  const finish = (e)=>{ e.preventDefault(); stopPTT(true); };
  ptt.addEventListener('mouseup', finish);
  ptt.addEventListener('mouseleave', (e)=>{ if (recorder) stopPTT(true); });
  ptt.addEventListener('touchend', finish, {passive:false});
  ptt.addEventListener('touchcancel', (e)=>{ e.preventDefault(); stopPTT(false); }, {passive:false});

  // Permission helper
  $('#micPermBtn').onclick = async (e) => {
    e.preventDefault();
    $('#micStatus').textContent = 'requesting mic‚Ä¶';
    const stream = await ensureMic();
    if (stream) {
      stream.getTracks().forEach(t => t.stop());
      $('#micPermBtn').classList.add('hidden');
      $('#micStatus').textContent = 'mic: granted';
    } else {
      $('#micStatus').textContent = 'mic: denied';
    }
  };

  // panel copy/clear
  $('#textCopy').onclick = ()=>copyText($('#textTokens'));
  $('#textClear').onclick = ()=>clearEl($('#textTokens'));
  $('#slidesCopy').onclick = ()=>copyText($('#slidesLog'));
  $('#slidesClear').onclick = ()=>clearEl($('#slidesLog'));
  $('#audioCopy').onclick = ()=>copyText($('#audioLog'));
  $('#audioClear').onclick = ()=>{ clearEl($('#audioLog')); clearAudioQueue(); };
  $('#evtCopy').onclick = ()=>copyText($('#evtLog'));
  $('#evtClear').onclick = ()=>clearEl($('#evtLog'));

  // boot
  initThree();
  updateMicPermBadge();
  </script>

</body>
</html>
